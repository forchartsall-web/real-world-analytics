``` {r}
# 0. Setup ----
required_pkgs <- c("readr","dplyr","ggplot2","GGally","corrplot",
                   "car","MASS","gridExtra","scales")

missing_pkgs <- required_pkgs[!(required_pkgs %in% installed.packages()[,"Package"])]
if (length(missing_pkgs)) {
  install.packages(missing_pkgs, repos = "https://cloud.r-project.org")
}

library(readr); library(dplyr); library(ggplot2); library(GGally); library(corrplot)
library(car); library(MASS); library(gridExtra); library(scales)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
data_path <- "ENB.txt"
```

``` {r}
# 1. Read data ----
raw <- read_table2(data_path, col_names = FALSE, skip = 1, progress = FALSE)
is_num_col <- sapply(raw, is.numeric)
df_num <- raw[, is_num_col]

if (ncol(df_num) > 6) {
  df_num <- df_num[ , (ncol(df_num)-5):ncol(df_num)]
}

colnames(df_num) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(df_num)

dim(df)
head(df)
```

``` {r}
# 2. Basic summary / missing values / types ----
summary_stats <- summary(df)
summary_stats

sapply(df, function(x) sum(is.na(x)))
```

``` {r}
# 3. Univariate plots (distribution) ----
plot_list <- list()

for (v in names(df)) {
  p_hist <- ggplot(df, aes_string(x = v)) +
    geom_histogram(aes(y = ..density..), bins = 30, fill = "steelblue", color = "white") +
    geom_density(alpha = 0.3, color = "red") +
    labs(title = paste("Histogram & density -", v)) +
    theme_minimal()

  p_box <- ggplot(df, aes_string(y = v)) +
    geom_boxplot(fill = "orange", alpha = 0.7) +
    labs(title = paste("Boxplot -", v)) +
    theme_minimal()

  plot_list[[paste0(v,"_hist")]] <- p_hist
  plot_list[[paste0(v,"_box")]] <- p_box

  print(p_hist)
  print(p_box)
}
```

``` {r}
# 4. Pairwise relationships ----
GGally::ggpairs(df, columns = 1:6, progress = FALSE)
```

``` {r}
# 5. Correlation matrix ----
cor_mat <- cor(df, use = "pairwise.complete.obs")
round(cor_mat, 3)

corrplot::corrplot(cor_mat, method = "ellipse", type = "upper", tl.cex = 0.8)
```

``` {r}
# 6. Multicollinearity checks ----
X <- as.matrix(df[, c("X1","X2","X3","X4","X5")])
eigs <- eigen(cor(X))
cond_number <- sqrt(max(eigs$values) / min(eigs$values))
cond_number

lm_full <- lm(Y ~ X1 + X2 + X3 + X4 + X5, data = as.data.frame(df_num))
vifs <- car::vif(lm_full)
vifs
```

``` {r}
# 7. Suggested transformations (empirical + Box-Cox for Y) ----
if (all(df$Y > 0)) {
  bc <- MASS::boxcox(lm_full, plotit = FALSE)
  lambda_est <- bc$x[which.max(bc$y)]
  lambda_est
} else {
  lambda_est <- NA
  lambda_est
}

skewness_num <- function(x) {
  m3 <- mean((x - mean(x))^3)
  s3 <- sd(x)^3
  m3 / s3
}
skews <- sapply(df, skewness_num)
round(skews, 3)
```

``` {r}
df_trans <- df
transform_notes <- list()

for (v in names(df)) {
  s <- skewness_num(df[[v]])
  if (s > 1) {
    if (all(df[[v]] > 0)) {
      df_trans[[v]] <- log(df[[v]])
      transform_notes[[v]] <- "log"
    } else {
      df_trans[[v]] <- sign(df[[v]]) * log(abs(df[[v]]) + 1)
      transform_notes[[v]] <- "signed_log"
    }
  } else if (s > 0.5) {
    if (all(df[[v]] >= 0)) {
      df_trans[[v]] <- sqrt(df[[v]])
      transform_notes[[v]] <- "sqrt"
    } else {
      df_trans[[v]] <- sign(df[[v]]) * sqrt(abs(df[[v]]))
      transform_notes[[v]] <- "signed_sqrt"
    }
  } else {
    transform_notes[[v]] <- "none"
  }
}
transform_notes
```

``` {r}
# 8. Re-check correlations & VIF on transformed predictors ----
X_t <- as.matrix(df_trans[, c("X1","X2","X3","X4","X5")])
cor_mat_t <- cor(cbind(X_t, Y = df_trans$Y), use = "pairwise.complete.obs")
round(cor_mat_t, 3)

corrplot::corrplot(cor_mat_t, method = "ellipse", type = "upper", tl.cex = 0.8)

lm_full_t <- lm(Y ~ X1 + X2 + X3 + X4 + X5, data = df_trans)
vifs_t <- car::vif(lm_full_t)
vifs_t
```

``` {r}
# 9. Guidance on multicollinearity ----
cat("- VIF > 5 (or >10) indicates problematic multicollinearity; consider removing or combining predictors,\n",
    "  or using dimensionality reduction (PCA) or regularized models (Ridge/Lasso).\n",
    "- If condition number >> 30, consider severe collinearity.\n",
    "- Consider centering (subtract mean) or scaling; add interaction terms only if justified.\n")
```