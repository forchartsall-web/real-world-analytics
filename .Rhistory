intall.package('LPSolve')
library(lpSolve)
install.packages("mgcv")
library(MASS, lib.loc = "C:/Program Files/R/R-4.5.2/library")
library(lattice, lib.loc = "C:/Program Files/R/R-4.5.2/library")
library(KernSmooth, lib.loc = "C:/Program Files/R/R-4.5.2/library")
install.packages("lpSove")
install.packages("lpSolve")
library(rpart, lib.loc = "C:/Program Files/R/R-4.5.2/library")
library(tools, lib.loc = "C:/Program Files/R/R-4.5.2/library")
setwd("C:/real-world-analytics")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 4)
# install missing packages if needed (comment out in controlled environments)
packages <- c("readr","dplyr","ggplot2","GGally","corrplot","car","MASS","gridExtra","knitr","kableExtra","scales")
installed <- packages %in% installed.packages()[,1]
if(any(!installed)) install.packages(packages[!installed], repos = "https://cloud.r-project.org")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 4)
# install missing packages if needed (comment out in controlled environments)
packages <- c("readr","dplyr","ggplot2","GGally","corrplot","car","MASS","gridExtra","knitr","kableExtra","scales")
installed <- packages %in% installed.packages()[,1]
if(any(!installed)) install.packages(packages[!installed], repos = "https://cloud.r-project.org")
library(readr); library(dplyr); library(ggplot2); library(GGally); library(corrplot)
library(car); library(MASS); library(gridExtra); library(knitr); library(kableExtra); library(scales)
# Path to uploaded file (already on disk)
data_path <- "ENB.txt"
# Read robustly assuming whitespace-delimited file
raw <- read_table2(data_path, col_names = FALSE, skip=1, progress = FALSE)
# Keep numeric columns only
is_num <- sapply(raw, is.numeric)
df_num <- raw[, is_num]
# If more than 6 numeric columns (common in ENB variants), keep last 6
if(ncol(df_num) > 6) df_num <- df_num[ , (ncol(df_num)-5):ncol(df_num)]
colnames(df_num) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(df_num)
glimpse(df)
summary(df)
sapply(df, function(x) sum(is.na(x)))
plots <- list()
for(v in names(df)) {
p1 <- ggplot(df, aes_string(x = v)) +
geom_histogram(aes(y=..density..), bins = 30) +
geom_density(alpha = 0.3) +
labs(title = paste("Histogram & density -", v)) +
theme_minimal()
p2 <- ggplot(df, aes_string(y = v)) +
geom_boxplot() + labs(title = paste("Boxplot -", v)) + theme_minimal()
plots[[paste0(v,"_h")]] <- p1
plots[[paste0(v,"_b")]] <- p2
}
# Arrange in a grid for preview (2 columns)
grid.arrange(plots$X1_h, plots$X1_b,
plots$X2_h, plots$X2_b,
plots$X3_h, plots$X3_b,
plots$X4_h, plots$X4_b,
plots$X5_h, plots$X5_b,
plots$Y_h,  plots$Y_b, ncol = 2)
GGally::ggpairs(df, columns = 1:6, progress = FALSE)
cor_mat <- cor(df, use = "pairwise.complete.obs")
print(round(cor_mat,3))
corrplot(cor_mat, method = "ellipse", type = "upper", tl.cex = 0.8)
# Condition number (eigen-based)
X <- as.matrix(df[, c("X1","X2","X3","X4","X5")])
eigs <- eigen(cor(X))
cond_number <- sqrt(max(eigs$values)/min(eigs$values))
cat("Condition number (sqrt(lambda_max/lambda_min)):", round(cond_number,3), "\n")
lm_full <- lm(Y ~ X1 + X2 + X3 + X4 + X5, data = df)
vifs <- car::vif(lm_full)
#vif_tbl <- data.frame(variable = names(vifs), VIF = as.numeric(vifs))
#kable(vif_tbl, caption = "VIFs for predictors") %>% kable_styling(full_width = FALSE)
stopifnot(is.data.frame(df))
library(MASS)
lm_full <- lm(Y ~ X1 + X2 + X3 + X4 + X5, data = df)
# --- Skewness Calculation ---
skewness_custom <- function(x) {
x <- x[!is.na(x)]
m3 <- mean((x - mean(x))^3)
s3 <- sd(x)^3
m3 / s3
}
skews <- sapply(df, skewness_custom)
skew_df <- data.frame(
variable = names(skews),
skewness = round(as.numeric(skews), 3)
)
#kable(skew_df, caption = "Skewness of Variables") %>%
#  kable_styling(full_width = FALSE)
# Box-Cox on Y (explicitly use MASS::boxcox)
if (all(is.finite(df$Y)) && all(df$Y > 0)) {
if(!requireNamespace("MASS", quietly = TRUE)) install.packages("MASS")
bc <- MASS::boxcox(lm_full, plotit = FALSE)
lambda_est <- bc$x[which.max(bc$y)]
cat("Suggested Box-Cox lambda for Y:", round(lambda_est, 3), "\n")
} else {
cat("Y contains non-positive or non-finite values â€” skipping Box-Cox on Y.\n")
}
