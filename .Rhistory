P=1
data.transformed[,4]=minmax(data.transformed[,4])
data.transformed[,4]=(data.transformed[,4])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.5
data.transformed[,5]=variables_to_transform[,5]
data.transformed[,5]=minmax(data.transformed[,5])
data.transformed[,5]=(data.transformed[,5])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.25
data.transformed[,5]=variables_to_transform[,5]
data.transformed[,5]=minmax(data.transformed[,5])
data.transformed[,5]=(data.transformed[,5])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1
data.transformed[,5]=variables_to_transform[,5]
data.transformed[,5]=minmax(data.transformed[,5])
data.transformed[,5]=(data.transformed[,5])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=0.85
data.transformed[,5]=variables_to_transform[,5]
data.transformed[,5]=minmax(data.transformed[,5])
data.transformed[,5]=(data.transformed[,5])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=0.85
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=0.75
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=0.15
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=3
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=2.5
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=2
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.85
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=2.85
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.85
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=2.25
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.25
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
P=1.15
data.transformed[,6]=variables_to_transform[,6]
data.transformed[,6]=minmax(data.transformed[,6])
data.transformed[,6]=(data.transformed[,6])^P
for (k in paste0("X", 1:6)) { hist(data.transformed[, k], main = k, xlab = k) }
save.image("~/REAL WORLD ANALYTICS/data.RData")
write.table(data.transformed, "balaji-transformed.txt")
source("AggWaFit718.R")
data.transformed_copy <- as.matrix(read.table("balaji-transformed.txt"))
save.image("~/REAL WORLD ANALYTICS/data.RData")
data.transformed_copy[1,1]
fit.QAM(data.transformed_copy)
data.transformed_copy[1,1]
fit.QAM(data.transformed_copy,output.1="powermean.txt",stats.1 = "powermean-stats.txt",g=PM05,g.inv=invPM05)
fit.OWA(data.transformed_copy,output.1="OWA.txt",stats.1 = "OWA-stats.txt")
save.image("~/REAL WORLD ANALYTICS/data.RData")
the.data <- as.matrix(read.table("ENB.txt"))
set.seed(226156731)
num_row<-650
my.data <- the.data[sample(1:nrow(the.data),num_row), 2:7]
head(my.data)
my.data <- the.data[sample(1:nrow(the.data),num_row), 2:7]
head(my.data)
colnames(my.data)<- c("X1","X2","X3","X4","X5","Y")
head(my.data)
# Choose the source matrix
src <- my.data  # or use the.data
# If there is a leading index column, drop it
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
# Ensure column names exist; assign if needed
if (is.null(colnames(src)) || !all(colnames(src) %in% c("X1","X2","X3","X4","X5","Y"))) {
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
}
# Set a 2x3 layout for five plots
op <- par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
plot(src[,"X1"], src[,"Y"], xlab = "X1: Living room temp (°C)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X1 vs Y")
abline(lm(Y ~ X1, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X2"], src[,"Y"], xlab = "X2: Living room humidity (%)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X2 vs Y")
abline(lm(Y ~ X2, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X3"], src[,"Y"], xlab = "X3: Office temp (°C)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X3 vs Y")
abline(lm(Y ~ X3, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X4"], src[,"Y"], xlab = "X4: Office humidity (%)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X4 vs Y")
abline(lm(Y ~ X4, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X5"], src[,"Y"], xlab = "X5: Pressure (mmHg)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X5 vs Y")
abline(lm(Y ~ X5, data = as.data.frame(src)), col = "red", lwd = 2)
par(op)
# install.packages("ggplot2") # if needed
library(ggplot2)
src <- my.data
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(src)
long <- reshape(
df,
varying = list(names(df)[1:5]),
v.names = "X",
timevar = "Feature",
times = names(df)[1:5],
direction = "long"
)
ggplot(long, aes(x = X, y = Y)) +
geom_point(alpha = 0.4, color = "steelblue") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
facet_wrap(~ Feature, scales = "free_x") +
labs(x = "Feature value", y = "Y: Appliances (Wh)", title = "Scatter plots: X1–X5 vs Y") +
theme_minimal(base_size = 12)
library(ggplot2)
src <- my.data  # or the.data
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(src)
long <- reshape(
df,
varying = list(names(df)[1:5]),
v.names = "X",
timevar = "Feature",
times = names(df)[1:5],
direction = "long"
)
p <- ggplot(long, aes(x = X, y = Y)) +
geom_point(alpha = 0.4, color = "steelblue") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
facet_wrap(~ Feature, scales = "free_x", nrow = 1) +  # single row
labs(x = "Feature value", y = "Y: Appliances (Wh)",
title = "Scatter plots: X1–X5 vs Y") +
theme_minimal(base_size = 13) +
theme(
plot.margin = margin(10, 20, 10, 20),
strip.text = element_text(size = 12),
axis.text.x = element_text(angle = 0, hjust = 0.5)
)
p
par(mfrow=c(2,3))
for (k in paste0("X", 1:5)) { hist(my.data[, k], main = k, xlab = k) }
library(MASS)
boxcox_transform <- function(x, lambda_seq = seq(-6, 6, by = 0.1), plot = FALSE) {
# x: numeric vector (positive values for Box–Cox)
# lambda_seq: grid of lambda values to search over
# plot: whether to show the boxcox profile plot
# Fit Box–Cox over an intercept-only model
bc <- boxcox(x ~ 1, lambda = lambda_seq, plotit = plot)
# Choose lambda that maximizes log-likelihood
lambda_hat <- bc$x[which.max(bc$y)]
# Apply the transformation
if (abs(lambda_hat) < 1e-6) {
x_bc <- log(x)
} else {
x_bc <- (x^lambda_hat - 1) / lambda_hat
}
# Return both transformed data and chosen lambda
list(
x_bc  = x_bc,
lambda = lambda_hat
)
}
I <- c( 'X1', 'X2', 'X3', 'X4', 'X5','Y')
variables_to_transform <- my.data[,I]
lambda=boxcox_transform(variables_to_transform[,"Y"],plot=TRUE)$lambda
variables_to_transform[,"Y"]=boxcox_transform(variables_to_transform[,"Y"],plot=TRUE)$x_bc
variables_to_transform[,"X1"]=boxcox_transform(variables_to_transform[,"X1"],plot=TRUE)$x_bc
variables_to_transform[,"X2"]=boxcox_transform(variables_to_transform[,"X2"],plot=TRUE)$x_bc
variables_to_transform[,"X3"]=boxcox_transform(variables_to_transform[,"X3"],plot=TRUE)$x_bc
variables_to_transform[,"X4"]=boxcox_transform(variables_to_transform[,"X4"],plot=TRUE)$x_bc
variables_to_transform[,"X5"]=boxcox_transform(variables_to_transform[,"X5"],plot=TRUE)$x_bc
head(variables_to_transform)
hist(variables_to_transform[, "Y"], main = "Y", xlab = "Y")
for (k in paste0("X", 1:5)) { hist(variables_to_transform[, k], main = k, xlab = k) }
data.transformed=variables_to_transform;
for (k in paste0("X", 1:5)) {  data.transformed[,k]=minmax(data.transformed[,k]);
hist(data.transformed[, k], main = k, xlab = k) }
data.transformed[,'Y']=minmax(variables_to_transform[,'Y']);
hist(data.transformed[,'Y'], main = 'Y', xlab = 'Y')
source("AggWaFit.R")
data.transformed_copy <- data.transformed
#as.matrix(read.table("balaji-transformed.txt"))
fit.QAM(data.transformed_copy,output.1="WAM3.txt",stats.1 = "WAM-stats3.txt")
data.transformed_copy[1,1]
length(data.transformed[,6])
fit.QAM(data.transformed_copy,output.1="powermean3.txt",stats.1 = "powermean-stats3.txt",g=PM05,g.inv=invPM05)
the.data <- as.matrix(read.table("ENB.txt"))
set.seed(226156731)
num_row<-650
my.data <- the.data[sample(1:nrow(the.data),num_row), 2:7]
head(my.data)
colnames(my.data)<- c("X1","X2","X3","X4","X5","Y")
head(my.data)
# Choose the source matrix
src <- my.data  # or use the.data
# If there is a leading index column, drop it
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
# Ensure column names exist; assign if needed
if (is.null(colnames(src)) || !all(colnames(src) %in% c("X1","X2","X3","X4","X5","Y"))) {
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
}
# Set a 2x3 layout for five plots
op <- par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
plot(src[,"X1"], src[,"Y"], xlab = "X1: Living room temp (°C)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X1 vs Y")
abline(lm(Y ~ X1, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X2"], src[,"Y"], xlab = "X2: Living room humidity (%)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X2 vs Y")
abline(lm(Y ~ X2, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X3"], src[,"Y"], xlab = "X3: Office temp (°C)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X3 vs Y")
abline(lm(Y ~ X3, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X4"], src[,"Y"], xlab = "X4: Office humidity (%)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X4 vs Y")
abline(lm(Y ~ X4, data = as.data.frame(src)), col = "red", lwd = 2)
plot(src[,"X5"], src[,"Y"], xlab = "X5: Pressure (mmHg)", ylab = "Y: Appliances (Wh)",
pch = 19, col = rgb(0,0,1,0.4), main = "X5 vs Y")
abline(lm(Y ~ X5, data = as.data.frame(src)), col = "red", lwd = 2)
par(op)
# install.packages("ggplot2") # if needed
library(ggplot2)
src <- my.data
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(src)
long <- reshape(
df,
varying = list(names(df)[1:5]),
v.names = "X",
timevar = "Feature",
times = names(df)[1:5],
direction = "long"
)
ggplot(long, aes(x = X, y = Y)) +
geom_point(alpha = 0.4, color = "steelblue") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
facet_wrap(~ Feature, scales = "free_x") +
labs(x = "Feature value", y = "Y: Appliances (Wh)", title = "Scatter plots: X1–X5 vs Y") +
theme_minimal(base_size = 12)
library(ggplot2)
src <- my.data  # or the.data
if (ncol(src) == 7) src <- src[, 2:7, drop = FALSE]
colnames(src) <- c("X1","X2","X3","X4","X5","Y")
df <- as.data.frame(src)
long <- reshape(
df,
varying = list(names(df)[1:5]),
v.names = "X",
timevar = "Feature",
times = names(df)[1:5],
direction = "long"
)
p <- ggplot(long, aes(x = X, y = Y)) +
geom_point(alpha = 0.4, color = "steelblue") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
facet_wrap(~ Feature, scales = "free_x", nrow = 1) +  # single row
labs(x = "Feature value", y = "Y: Appliances (Wh)",
title = "Scatter plots: X1–X5 vs Y") +
theme_minimal(base_size = 13) +
theme(
plot.margin = margin(10, 20, 10, 20),
strip.text = element_text(size = 12),
axis.text.x = element_text(angle = 0, hjust = 0.5)
)
p
par(mfrow=c(2,3))
for (k in paste0("X", 1:5)) { hist(my.data[, k], main = k, xlab = k) }
hist(my.data[, "Y"], main = "Y", xlab = "Y")
# minmax normalisation
minmax <- function(x){
(x - min(x))/(max(x)-min(x))
}
# z-score standardisation and scaling to unit interval
unit.z <- function(x){
0.15*((x-mean(x))/sd(x)) + 0.5
}
library(MASS)
boxcox_transform <- function(x, lambda_seq = seq(-2, 2, by = 0.1), plot = FALSE) {
# x: numeric vector (positive values for Box–Cox)
# lambda_seq: grid of lambda values to search over
# plot: whether to show the boxcox profile plot
# Fit Box–Cox over an intercept-only model
bc <- boxcox(x ~ 1, lambda = lambda_seq, plotit = plot)
# Choose lambda that maximizes log-likelihood
lambda_hat <- bc$x[which.max(bc$y)]
# Apply the transformation
if (abs(lambda_hat) < 1e-6) {
x_bc <- log(x)
} else {
x_bc <- (x^lambda_hat - 1) / lambda_hat
}
# Return both transformed data and chosen lambda
list(
x_bc  = x_bc,
lambda = lambda_hat
)
}
normality_score_sw <- function(x, n) {
x_t <- x ^ n
# Remove NAs just in case
x_t <- x_t[is.finite(x_t)]
# Need at least 3 distinct values for a sensible test
if (length(unique(x_t)) < 3) return(NA_real_)
shapiro.test(x_t)$p.value
}
find_n_shapiro <- function(x, n_grid = seq(0, 2, by = 0.05)) {
scores <- sapply(n_grid, function(n) normality_score_sw(x, n))
# Exclude NA scores
valid  <- !is.na(scores)
if (!any(valid)) stop("No valid n in the grid (all transforms constant or invalid).")
best_i <- which.max(scores[valid])
list(
n_opt   = n_grid[valid][best_i],
p_opt   = scores[valid][best_i],
grid    = n_grid,
scores  = scores
)
}
fit.QAM(data.transformed_copy,output.1="WAM3.txt",stats.1 = "WAM-stats3.txt")
I <- c( 'X1', 'X2', 'X3', 'X4', 'X5','Y')
variables_to_transform <- my.data[,I]
head(variables_to_transform)
res_swY=find_n_shapiro(variables_to_transform[,"Y"])
variables_to_transform[,"Y"]=variables_to_transform[,"Y"]^res_swY$n_opt
res_swX1=find_n_shapiro(variables_to_transform[,"X1"])
variables_to_transform[,"X1"]=variables_to_transform[,"X1"]^res_swX1$n_opt
res_swX2=find_n_shapiro(variables_to_transform[,"X2"])
variables_to_transform[,"X2"]=variables_to_transform[,"X2"]^res_swX2$n_opt
res_swX3=find_n_shapiro(variables_to_transform[,"X3"])
variables_to_transform[,"X3"]=variables_to_transform[,"X3"]^res_swX3$n_opt
res_swX4=find_n_shapiro(variables_to_transform[,"X4"])
variables_to_transform[,"X4"]=variables_to_transform[,"X4"]^res_swX4$n_opt
res_swX5=find_n_shapiro(variables_to_transform[,"X5"])
variables_to_transform[,"X5"]=variables_to_transform[,"X5"]^res_swX5$n_opt
head(variables_to_transform)
hist(variables_to_transform[, "Y"], main = "Y", xlab = "Y")
for (k in paste0("X", 1:5)) { hist(variables_to_transform[, k], main = k, xlab = k) }
data.transformed=variables_to_transform;
write.table(data.transformed, "balaji-transformed.txt")
source("AggWaFit718.R")
data.transformed_copy <- data.transformed
#as.matrix(read.table("balaji-transformed.txt"))
epsilon <- 1e-6
data.transformed_copy[data.transformed_copy == 0] <- epsilon
fit.QAM(data.transformed_copy,output.1="WAM3.txt",stats.1 = "WAM-stats3.txt")
data.transformed_copy[1,1]
length(data.transformed[,6])
fit.QAM(data.transformed_copy,output.1="powermean3.txt",stats.1 = "powermean-stats3.txt",g=PM05,g.inv=invPM05)
fit.QAM(data.transformed_copy,output.1="powermean32.txt",stats.1 = "powermean-stats32.txt",g=QM,g.inv=invQM)
fit.QAM(data.transformed_copy,output.1="powermean3-1.txt",stats.1 = "powermean-stats3-1.txt",g=HM,g.inv=invHM)
fit.QAM(data.transformed_copy,output.1="powermean30.txt",stats.1 = "powermean-stats30.txt",g=GM,g.inv=invGM)
fit.OWA(data.transformed_copy,output.1="OWA3.txt",stats.1 = "OWA-stats3.txt")
fit.choquet(data.transformed_copy,output.1="choquet3.txt",stats.1 = "choquet-stats3.txt")
# Your data
new.data <- c(23.5, 35.87125, 24.89, 32.93, 758.55)
# Create a matrix with 1 row and 5 columns
new.data <- matrix(new.data, nrow = 1)
# Assign column names
colnames(new.data) <- c("X1", "X2", "X3", "X4", "X5")
# Check result
new.data
new_input_to_transform <- new.data
new_input_to_transform[,"X1"]=new_input_to_transform[,"X1"]^res_swX1$n_opt
new_input_to_transform[,"X2"]=new_input_to_transform[,"X2"]^res_swX2$n_opt
new_input_to_transform[,"X3"]=new_input_to_transform[,"X3"]^res_swX3$n_opt
new_input_to_transform[,"X4"]=new_input_to_transform[,"X4"]^res_swX4$n_opt
new_input_to_transform[,"X5"]=new_input_to_transform[,"X5"]^res_swX5$n_opt
new_input_to_transform
hist(variables_to_transform[, "Y"], main = "Y", xlab = "Y")
for (k in paste0("X", 1:5)) { hist(variables_to_transform[, k], main = k, xlab = k) }
# Your data
new.data <- c(23.5, 35.87125, 24.89, 32.93, 758.55)
# Create a matrix with 1 row and 5 columns
new.data <- matrix(new.data, nrow = 1)
# Assign column names
colnames(new.data) <- c("X1", "X2", "X3", "X4", "X5")
# Check result
new.data
# Load the weights from the best model (QM in this case
weights_QM <- c(0.934071643855891,0, 0.0659283561441099,0,0)
# call the function PM
result=PM(new_input_to_transform,weights_QM,-1)
#QAM(  x = new_input_to_transform,  w = weights_QM,  g = QM,  g.inv = invQM)
result_scaled=result
result_scaled
# Reverse min-max scaling for Y
result_scaled=result^(1/res_swY$n_opt)
result_scaled
# Reverse min-max scaling for Y
I <- c( 'X1', 'X2', 'X3', 'X4', 'X5','Y')
variables_to_transform <- my.data[,I]
head(variables_to_transform)
variables_to_transform[,"Y"]=minmax(variables_to_transform[,"Y"])+1e-6  #shift to make all values positive
variables_to_transform[,"X1"]=minmax(variables_to_transform[,"X1"])+1e-6
variables_to_transform[,"X2"]=minmax(variables_to_transform[,"X2"])+1e-6
variables_to_transform[,"X3"]=minmax(variables_to_transform[,"X3"])+1e-6
variables_to_transform[,"X4"]=minmax(variables_to_transform[,"X4"])+1e-6
variables_to_transform[,"X5"]=minmax(variables_to_transform[,"X5"])+1e-6
head(variables_to_transform)
#find optimal n for each variable and transform
res_swY=find_n_shapiro(variables_to_transform[,"Y"])
variables_to_transform[,"Y"]=variables_to_transform[,"Y"]^res_swY$n_opt
res_swX1=find_n_shapiro(variables_to_transform[,"X1"])
variables_to_transform[,"X1"]=variables_to_transform[,"X1"]^res_swX1$n_opt
res_swX2=find_n_shapiro(variables_to_transform[,"X2"])
variables_to_transform[,"X2"]=variables_to_transform[,"X2"]^res_swX2$n_opt
res_swX3=find_n_shapiro(variables_to_transform[,"X3"])
variables_to_transform[,"X3"]=variables_to_transform[,"X3"]^res_swX3$n_opt
res_swX4=find_n_shapiro(variables_to_transform[,"X4"])
variables_to_transform[,"X4"]=variables_to_transform[,"X4"]^res_swX4$n_opt
res_swX5=find_n_shapiro(variables_to_transform[,"X5"])
variables_to_transform[,"X5"]=variables_to_transform[,"X5"]^res_swX5$n_opt
head(variables_to_transform)
hist(variables_to_transform[, "Y"], main = "Y", xlab = "Y")
for (k in paste0("X", 1:5)) { hist(variables_to_transform[, k], main = k, xlab = k) }
data.transformed=variables_to_transform;
write.table(data.transformed, "balaji-transformed.txt")
data.transformed_copy <- data.transformed
#as.matrix(read.table("balaji-transformed.txt"))
fit.QAM(data.transformed_copy,output.1="WAM3.txt",stats.1 = "WAM-stats3.txt")
data.transformed_copy[1,1]
length(data.transformed[,6])
fit.QAM(data.transformed_copy,output.1="powermean3.txt",stats.1 = "powermean-stats3.txt",g=PM05,g.inv=invPM05)
fit.QAM(data.transformed_copy,output.1="powermean32.txt",stats.1 = "powermean-stats32.txt",g=QM,g.inv=invQM)
fit.QAM(data.transformed_copy,output.1="powermean3-1.txt",stats.1 = "powermean-stats3-1.txt",g=HM,g.inv=invHM)
fit.QAM(data.transformed_copy,output.1="powermean30.txt",stats.1 = "powermean-stats30.txt",g=GM,g.inv=invGM)
fit.OWA(data.transformed_copy,output.1="OWA3.txt",stats.1 = "OWA-stats3.txt")
fit.choquet(data.transformed_copy,output.1="choquet3.txt",stats.1 = "choquet-stats3.txt")
# Your data
new.data <- c(23.5, 35.87125, 24.89, 32.93, 758.55)
# Create a matrix with 1 row and 5 columns
new.data <- matrix(new.data, nrow = 1)
# Assign column names
colnames(new.data) <- c("X1", "X2", "X3", "X4", "X5")
# Check result
new.data
new_input_to_transform <- new.data
new_input_to_transform[,"X1"]=(new_input_to_transform[,"X1"]-min(my.data[,"X1"]))/(max(my.data[,"X1"])-min(my.data[,"X1"]))+1e-6
new_input_to_transform[,"X2"]=(new_input_to_transform[,"X2"]-min(my.data[,"X2"]))/(max(my.data[,"X2"])-min(my.data[,"X2"]))+1e-6
new_input_to_transform[,"X3"]=(new_input_to_transform[,"X3"]-min(my.data[,"X3"]))/(max(my.data[,"X3"])-min(my.data[,"X3"]))+1e-6
new_input_to_transform[,"X4"]=(new_input_to_transform[,"X4"]-min(my.data[,"X4"]))/(max(my.data[,"X4"])-min(my.data[,"X4"]))+1e-6
new_input_to_transform[,"X5"]=(new_input_to_transform[,"X5"]-min(my.data[,"X5"]))/(max(my.data[,"X5"])-min(my.data[,"X5"]))+1e-6
new_input_to_transform[,"X1"]=new_input_to_transform[,"X1"]^res_swX1$n_opt
new_input_to_transform[,"X2"]=new_input_to_transform[,"X2"]^res_swX2$n_opt
new_input_to_transform[,"X3"]=new_input_to_transform[,"X3"]^res_swX3$n_opt
new_input_to_transform[,"X4"]=new_input_to_transform[,"X4"]^res_swX4$n_opt
new_input_to_transform[,"X5"]=new_input_to_transform[,"X5"]^res_swX5$n_opt
new_input_to_transform
# Load the weights from the best model (QM in this case
weights_QM <- c(3.39590208736855e-05,0, 4.32966633027089e-07,0,7.84446783528281e-10)
# call the function PM
result=PM(new_input_to_transform,weights_QM,-1)
#QAM(  x = new_input_to_transform,  w = weights_QM,  g = QM,  g.inv = invQM)
result_scaled=result^(1/res_swY$n_opt)
result_scaled
# Reverse min-max scaling for Y
result_scaled=result^(1/res_swY$n_opt)
result_scaled
# Reverse min-max scaling for Y
original_min_Y <- min(my.data[,"Y"])
original_max_Y <- max(my.data[,"Y"])
result_original_scale <- result_scaled * (original_max_Y - original_min_Y) + original_min_Y
result_original_scale
# Load the weights from the best model (QM in this case
weights_QM <- c(0.934,0,0.066,0,0)
# call the function PM
result=PM(new_input_to_transform,weights_QM,-1)
#QAM(  x = new_input_to_transform,  w = weights_QM,  g = QM,  g.inv = invQM)
result_scaled=result^(1/res_swY$n_opt)
result_scaled
# Reverse min-max scaling for Y
original_min_Y <- min(my.data[,"Y"])
original_max_Y <- max(my.data[,"Y"])
result_original_scale <- result_scaled * (original_max_Y - original_min_Y) + original_min_Y
result_original_scale
